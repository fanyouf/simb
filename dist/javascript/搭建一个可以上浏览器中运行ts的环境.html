<!DOCTYPE html>  <html lang="en">    <head>      <meta charset="UTF-8" />      <meta name="viewport" content="width=device-width, initial-scale=1.0" />      <meta http-equiv="X-UA-Compatible" content="ie=edge" />      <meta name="author" content="凡友福" />      <meta name="keywords" content="搭建一个可以上浏览器中运行ts的环境" />      <title>搭建一个可以上浏览器中运行ts的环境|凡友福的个人博客</title>      <link rel="stylesheet" href="../css/index.css" />      <meta name="description" content="" />    </head>      <body class="article">      <header class="m-header">        <div class="container">          <h1 class="m-logo" title=""><a href="./index">凡友福的博客</a></h1>          <nav class="m-nav">            <a href="../index.html">首页</a>            <a href="../archive.html">归档</a>            <a href="../category.html">分类</a>            <!-- <a href="../about.html">关于</a> -->          </nav>        </div>      </header>      <section class="wrapper">        <div class="main">          <h1 class="h1">            搭建一个可以上浏览器中运行ts的环境          </h1>          <div class="meta">            <span class="category"              >分类于：<a href="../category.html#javascript"                >javascript</a              ></span            >                        <div class="tag">标签：typescript,gulp</div>                        <span class="dateTime">发表于：2019-04-16</span>          </div>          <article class="m-markdown">            <p><a href="github.com/fanyoufu/learnty.git">github 地址</a></p>
<p>目录
[[toc]]</p>
<h2>建立目录结构</h2>
<pre><code>package.json
src/
dist/
</code></pre>
<p>建议使用 npm init 初始化 package.json 文件</p>
<h2>安装 gulp 和 typescript</h2>
<ol>
<li>全局安装 gulp</li>
</ol>
<pre><code>npm install -g gulp-cli
</code></pre>
<p><img src="./2019-04-16%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Cts%E7%9A%84%E7%8E%AF%E5%A2%83_typescript-gulp/01.png" alt="ddd"></p>
<ol start="2">
<li>安装 typescript，gulp 和 gulp-typescript 到开发依赖项。</li>
</ol>
<pre><code>npm install --save-dev typescript gulp gulp-typescript
</code></pre>
<ul>
<li>typscript 是 typescript 的编译器</li>
<li>gulp-typescript 是与 gulp 配合使用的 gulp 插件</li>
</ul>
<h2>编写 ts 文件</h2>
<blockquote>
<p>目录/src/main.ts</p>
</blockquote>
<pre><code>function hello(compiler: string) {
    console.log(`Hello from ${compiler}`);
}
hello(&quot;TypeScript&quot;);
</code></pre>
<h2>配置 tsconfig 文件</h2>
<p>在项目根目录下建立 tsconfig.json 文件。</p>
<blockquote>
<p>目录/tsconfig.json</p>
</blockquote>
<pre><code>{
    &quot;files&quot;: [
        &quot;src/main.ts&quot;
    ],
    &quot;compilerOptions&quot;: {
        &quot;noImplicitAny&quot;: true,
        &quot;target&quot;: &quot;es5&quot;
    }
}
</code></pre>
<h2>配置 gulpfile.js 文件</h2>
<p>在项目目录下建立 gulpfile.js 文件，来配置 gulp 命令</p>
<blockquote>
<p>目录/gulpfile.js 文件</p>
</blockquote>
<pre><code>var gulp = require(&quot;gulp&quot;);
var ts = require(&quot;gulp-typescript&quot;);
var tsProject = ts.createProject(&quot;tsconfig.json&quot;);

gulp.task(&quot;default&quot;, function () {
    return tsProject.src()
        .pipe(tsProject())
        .js.pipe(gulp.dest(&quot;dist&quot;));
});
</code></pre>
<h2>运行 gulp 命令，查看效果</h2>
<pre><code>gulp
node dist/main.js
</code></pre>
<ul>
<li>gulp 命令通过 gulpfile.js 的配置，把 src/main.ts 编译成 dist/main.js 文件。
此时在 dist 下会生成一个 main.js 文件，其文件的内容是：</li>
</ul>
<pre><code>function hello(compiler) {
    console.log(&quot;hello from &quot; + compiler);
}
hello(&quot;TypeScript&quot;);
</code></pre>
<p>你可以回过去对比看看 main.ts 的内容和现在的 main.js 的内容对比。</p>
<ul>
<li>node dist/main.js 命令是在 node 环境中执行 main.js</li>
</ul>
<p>以上是在 node 中执行 javascript，那如何把 javascript 放在浏览器中执行呢？
其实你可以直接把这个 main.js 引入到你的 html 页面中。</p>
<h2>使用多个 ts 文件</h2>
<p>现实中的项目目录肯定会有很多个模块，表现在多离散的文件中。下面来尝试一下：</p>
<p>共三步.</p>
<h3>1/3 新建一个 src/greet.ts 文件：</h3>
<pre><code>export function sayHello(name: string) {
    return `Hello from ${name}`;
}
</code></pre>
<h3>2/3 更改 src/main.ts 代码，从 greet.ts 导入 sayHello：</h3>
<pre><code>import { sayHello } from &quot;./greet&quot;;

console.log(sayHello(&quot;TypeScript&quot;));
</code></pre>
<h3>3/3 最后，将 src/greet.ts 添加到 tsconfig.json：</h3>
<pre><code>{
    &quot;files&quot;: [
        &quot;src/main.ts&quot;,
        &quot;src/greet.ts&quot;
    ],
    &quot;compilerOptions&quot;: {
        &quot;noImplicitAny&quot;: true,
        &quot;target&quot;: &quot;es5&quot;
    }
}
</code></pre>
<p>注意：files 的值是一个数组，数组中最后一个元素不要加“,”。如果你加了，有可能会在接下来的任务中出错。</p>
<p>确保执行 gulp 后模块是能工作的，在 Node.js 下进行测试：</p>
<pre><code>gulp
node dist/main.js
</code></pre>
<p>你会得到如下：
dist/main.js</p>
<pre><code>&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
var greet_1 = require(&quot;./greet&quot;);
console.log(greet_1.sayHello(&quot;Typescript&quot;));

</code></pre>
<p>dist/greet.js</p>
<pre><code>&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
function sayHello(name) {
    return &quot;Hello from &quot; + name;
}
exports.sayHello = sayHello;
</code></pre>
<p>注意，此时，你如果直接在.html 文件中引用 dist/main.js 文件是会出错误的。原因是：浏览器中不认识 require 命令。 而在 node 环境是可以执行 node main.js 的，因为 node 支持 commonJS 的模块化。</p>
<p>我们来证明这一点。</p>
<h2>在浏览器环境中使用 main.js</h2>
<h3>创建 src/index.html 文件</h3>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p id=&quot;greeting&quot;&gt;loading....&lt;/p&gt;
    &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3>把 index.htm 从 src 目标拷贝到 dist 目录</h3>
<p>为什么不直接在 dist 目录下创建这个 index.html 文件，而非要在 src 目录下创建好了再复制过去呢？ 因为 src 是源目录，dist 是生产目录，我们只能把代码写在源目录中。</p>
<p>这个拷贝的过程是通过建立 gulp 任务来完成的</p>
<pre><code>let gulp = require(&quot;gulp&quot;)

let ts = require(&quot;gulp-typescript&quot;)
let tsProject = ts.createProject(&quot;tsconfig.json&quot;);

let paths = {
    pages:[&quot;src/*.html&quot;]
}
gulp.task(&quot;copy-html&quot;,function(){
    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))
});

gulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,function(){
    return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(&quot;dist&quot;))
}))
</code></pre>
<p>这里增加了 copy-html 任务并且把它加作 default 的依赖项。 这样，当 default 执行时，copy-html 会被首先执行。</p>
<p>注意：default 是默认任务，而第二个参数 gulp.series()这种写法是 gulp4.0 的写法。gulp3.0 的写法有个一点小区别。请大家根据自己 gulp 的版本来决定。</p>
<p>改造完 gulpfile.js 后，再次运行</p>
<pre><code>gulp
</code></pre>
<p>可以看这个两个任务的结果:</p>
<ol>
<li>index.html 拷贝到了 dist 目录</li>
<li>main.ts,greet.ts 被编译成了对应的.js 文件。</li>
</ol>
<h3>浏览器中的 export 错误</h3>
<p>此时，我们通过浏览器打开 index.html 文件，你会在浏览器中看到错误信息：</p>
<pre><code>main.js:2 Uncaught ReferenceError: exports is not defined
    at main.js:2
</code></pre>
<p>那么，如何解决呢？</p>
<h2>工程由 Node.js 环境移到浏览器环境里</h2>
<p>现在，让我们把这个工程由 Node.js 环境移到浏览器环境里。 通过 Browserify 把所有模块捆绑成一个 JavaScript 文件。</p>
<h3>安装依赖</h3>
<pre><code>npm install --save-dev browserify tsify vinyl-source-stream
</code></pre>
<p>首先，安装 Browserify，tsify 和 vinyl-source-stream。 tsify 是 Browserify 的一个插件，就像 gulp-typescript 一样，它能够访问 TypeScript 编译器。 vinyl-source-stream 会将 Browserify 的输出文件适配成 gulp 能够解析的格式，它叫做 vinyl。</p>
<h3>修改 gulpfile.js 配置</h3>
<p>几个要点：</p>
<ol>
<li>使用 browserify 处理 typescript 文件的插件 tsify 来代替 gulp-typescript</li>
<li>配置 browserify()打包.js 文件到 bundle.js</li>
</ol>
<pre><code>let gulp = require(&quot;gulp&quot;)

let browserify =require(&quot;browserify&quot;)
let source = require(&quot;vinyl-source-stream&quot;)
let tsify = require(&quot;tsify&quot;);

// let ts = require(&quot;gulp-typescript&quot;)
// let tsProject = ts.createProject(&quot;tsconfig.json&quot;);

let paths = {
    pages:[&quot;src/*.html&quot;]
}
gulp.task(&quot;copy-html&quot;,function(){
    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))
});

gulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,function(){
    // return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(&quot;dist&quot;))
    return browserify({
        basedir:&quot;&quot;,
        debug:true,
        entries:[&quot;src/main.ts&quot;],
        cache:{},
        packageCache:{}
    }).plugin(tsify)
    .bundle()
    .pipe(source('bundle.js'))
    .pipe(gulp.dest(&quot;dist&quot;));
}))
</code></pre>
<p>修改了 default 任务，让它使用 tsify 插件调用 Browserify，而不是 gulp-typescript。 方便的是，两者传递相同的参数对象到 TypeScript 编译器。</p>
<p>调用 bundle 后，我们使用 source（vinyl-source-stream 的别名）把输出文件命名为 bundle.js。</p>
<p>注意，我们为 Broswerify 指定了 debug: true。 这会让 tsify 在输出文件里生成 source maps。 source maps 允许我们在浏览器中直接调试 TypeScript 源码，而不是在合并后的 JavaScript 文件上调试。 你要打开调试器并在 main.ts 里打一个断点，看看 source maps 是否能工作。 当你刷新页面时，代码会停在断点处，从而你就能够调试 greet.ts。</p>
<ol start="3">
<li>修改 src/index.html 中的的 js 文件引用</li>
</ol>
<p>此时，应该引用 ./boundle.js</p>
<ol start="4">
<li>运行命令 gulp</li>
</ol>
<pre><code>gulp
</code></pre>
<ol start="5">
<li>观察./dist/bundle.js</li>
</ol>
<p>bundle.js</p>
<pre><code>(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module '&quot;+i+&quot;'&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
function sayHello(name) {
    return &quot;Hello from &quot; + name;
}
exports.sayHello = sayHello;
},{}],2:[function(require,module,exports){
&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
var greet_1 = require(&quot;./greet&quot;);
console.log(greet_1.sayHello(&quot;Typescript&quot;));
},{&quot;./greet&quot;:1}]},{},[2])

</code></pre>
<ol start="6">
<li>打开 dist/index.html 文件
你应该可以在控制台中看到正确的输出了。</li>
</ol>
<h3>自动构建</h3>
<p>在编辑保存.ts 时，能立即看到效果。</p>
<h4>安装 watchify 包</h4>
<pre><code>npm install --save-dev watchify gulp-util
</code></pre>
<p>Watchify 启动 Gulp 并保持运行状态，当你保存文件时自动编译。 帮你进入到编辑-保存-刷新浏览器的循环中。</p>
<h4>修改 gulpfile.js 配置</h4>
<p>共有三处改变，但是需要你略微重构一下代码。</p>
<p>(1) 将 browserify 实例包裹在 watchify 的调用里，控制生成的结果。
(2) 调用 watchedBrowserify.on(&quot;update&quot;, bundle);，每次 TypeScript 文件改变时 Browserify 会执行 bundle 函数。
(3) 调用 watchedBrowserify.on(&quot;log&quot;, gutil.log);将日志打印到控制台。</p>
<p>(1)和(2)在一起意味着我们要将 browserify 调用移出 default 任务。 然后给函数起个名字，因为 Watchify 和 Gulp 都要调用它。 (3)是可选的，但是对于调试来讲很有用。</p>
<pre><code>let gulp = require(&quot;gulp&quot;)

let browserify =require(&quot;browserify&quot;)
let source = require(&quot;vinyl-source-stream&quot;)
let tsify = require(&quot;tsify&quot;);
let watchify = require(&quot;watchify&quot;)
let gutil = require(&quot;gulp-util&quot;)

var wathchedBrowerify = watchify(browserify({
    basedir:&quot;&quot;,
    debug:true,
    entries:[&quot;src/main.ts&quot;],
    cache:{},
    packageCache:{}
})).plugin(tsify)

let paths = {
    pages:[&quot;src/*.html&quot;]
}
gulp.task(&quot;copy-html&quot;,function(){
    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))
});
function bundle(){
    return wathchedBrowerify.bundle().pipe(source('bundle.js'))
    .pipe(gulp.dest(&quot;dist&quot;));
}
gulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,bundle));

wathchedBrowerify.on(&quot;update&quot;,bundle);
wathchedBrowerify.on(&quot;log&quot;,gutil.log)
</code></pre>
<h3>浏览器自动刷新</h3>
<h4>安装 live-server</h4>
<p>live-server 与我们上面介绍的 typescript，gulp 都没有关系。 你只需要全局安装 live-server。然后进入 dist 目录，运行 live-server 即可看到效果。</p>
<p>它的<a href="https://www.npmjs.com/package/live-server">npm 地址</a></p>
<pre><code>npm install -g live-server
cd dist
live-server
</code></pre>
<h2>在 gulp 中使用 less</h2>
<h3>准备好目录</h3>
<p>dist/css</p>
<p>src/less</p>
<h3>安装 gulp-less 包</h3>
<pre><code>npm install gulp-less --dev
</code></pre>
<h3>修改 gulpfile 配置</h3>
<pre><code>let gulp = require(&quot;gulp&quot;)

let browserify =require(&quot;browserify&quot;)
let source = require(&quot;vinyl-source-stream&quot;)
let tsify = require(&quot;tsify&quot;);
let watchify = require(&quot;watchify&quot;)
let gutil = require(&quot;gulp-util&quot;)

const less = require('gulp-less')

var wathchedBrowerify = watchify(browserify({
    basedir:&quot;&quot;,
    debug:true,
    entries:[&quot;src/main.ts&quot;],
    cache:{},
    packageCache:{}
})).plugin(tsify)

let paths = {
    pages:[&quot;src/*.html&quot;]
}

gulp.task('less', function () {
    return gulp.src('src/less/**/*.less')
      .pipe(less())
      .pipe(gulp.dest('dist/css'));
  });

gulp.task(&quot;copy-html&quot;,function(){
    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))
});
function bundle(){
    return wathchedBrowerify.bundle().pipe(source('bundle.js'))
    .pipe(gulp.dest(&quot;dist&quot;));
}
gulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,&quot;less&quot;,bundle));

gulp.watch(['src/less/*.less','src/index.html'], gulp.series('less','copy-html'));

wathchedBrowerify.on(&quot;update&quot;,bundle);
wathchedBrowerify.on(&quot;log&quot;,gutil.log)

</code></pre>
<h2>end</h2>
<p>至此，我们搭建一个可以写 ts 代码，并在浏览器环境中运行的开发环境。</p>
          </article>        </div>        <aside id="asideContianer">          <dl class="m-list outline-content" id="aside">            <dt class="m-list-title " id="asideTitle">目录</dt>              <dd class="m-list-item"></dd>          </dl>        </aside>      </section>        <script>        function buildCagloute() {          var asideDom = document.getElementById('aside');          var articleDom = document.querySelector('.m-markdown');          var hList = articleDom.querySelectorAll('h1,h2,h3,h4,h5,h6');            for (var i = 0; i < hList.length; i++) {            var item = hList[i];            var aTarget = document.createElement('a');            aTarget.id = item.innerHTML;            item.parentNode.insertBefore(aTarget, item);            var level = item.nodeName.substr(1, 1);              var alink = document.createElement('a');            alink.innerHTML = item.innerHTML;            alink.href = '#' + item.innerHTML;            alink.className = 'pl' + level + ' outline-h' + level;            alink.level = level;              var dt = document.createElement('dt');            dt.className = 'm-list-item';              dt.appendChild(alink);              asideDom.appendChild(dt);          }        }          window.onload = function() {          buildCagloute();            var aside = document.getElementById('aside');            var last_known_scroll_position = 0;          var ticking = false;            function doSomething(scroll_pos) {            aside.style.transform = 'translateY(' + scroll_pos + 'px)';              console.info('Do something with the scroll position');          }            function hScroll() {            last_known_scroll_position = window.scrollY;              if (!ticking) {              window.requestAnimationFrame(function() {                doSomething(last_known_scroll_position);                ticking = false;              });                ticking = true;            }          }          function throttle(f, dela) {            dela = dela || 500;            var timer = null;            return function() {              if (timer) {                clearTimeout(timer);              }              timer = setTimeout(function() {                f();              }, dela);            };          }          var fScroll = throttle(hScroll);            window.addEventListener('scroll', function() {            fScroll();          });        };          // function SideBar(config = {status:"close", domId:"domId"}){        //   this.sideBarDom = document.getElementById(domId);          //   this.btn = document.getElementById("asideTitle");          //   if(config.status === "close"){        //     this.sideBarDom.style.width = "0";        //   }          // }      </script>    </body>  </html>  