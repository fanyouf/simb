[{"cou_id":"01","name":"javascript入门","full_name":"01_javascript入门","slug_name":"javascript-ru-men","article_list":[{"substr":"  搭建一个可以在浏览器环境中运行ts的环境\r\n\r\n在学习typescript中过程中我们遇到的第一个问题就是在哪去运行ts代码（不像js可以直接在浏览器中运行，ts需要先进行编译，转成js代码之后，","content":"<h1>搭建一个可以在浏览器环境中运行ts的环境</h1>\n<p>在学习typescript中过程中我们遇到的第一个问题就是在哪去运行ts代码（不像js可以直接在浏览器中运行，ts需要先进行编译，转成js代码之后，才能运行。），我最提供一个最简单的环境来运行ts代码，所以本文从零开始介绍了如何去搭建在浏览器环境下使用ts编写代码的环境。</p>\n<p>整体分成如下几步：</p>\n<ul>\n<li>建立基本目录</li>\n<li>安装依赖</li>\n<li>修改配置</li>\n<li>验收效果</li>\n</ul>\n<h2>建立目录结构</h2>\n<pre><code>package.json\nsrc/\ndist/\n</code></pre>\n<p>建议使用 <code>npm init</code> 来初始化 <code>package.json</code> 文件。</p>\n<p>其中 src 就是用来存放ts文件，dist是编译之后的文件。</p>\n<h2>安装 gulp 和 typescript</h2>\n<ol>\n<li>全局安装 gulp</li>\n</ol>\n<pre><code>npm install -g gulp-cli\n</code></pre>\n<ol start=\"2\">\n<li>安装 typescript，gulp 和 gulp-typescript 到开发依赖项。</li>\n</ol>\n<pre><code>npm install --save-dev typescript gulp gulp-typescript\n</code></pre>\n<ul>\n<li>typescript 是 <code>typescript</code>的编译器，它用来把ts编译成js</li>\n<li>gulp-typescript 是与 gulp 配合使用的 gulp 插件</li>\n</ul>\n<h2>通过gulp命令来编译第一个ts文件</h2>\n<h3>写第一个ts 文件</h3>\n<p>把在/src下新建main.ts文件，内容如下：</p>\n<pre><code>function hello(compiler: string) {\n    console.log(`Hello from ${compiler}`);\n}\nhello(&quot;TypeScript&quot;);\n</code></pre>\n<h3>配置 tsconfig 文件</h3>\n<p>在项目根目录下建立 tsconfig.json 文件。</p>\n<blockquote>\n<p>目录/tsconfig.json</p>\n</blockquote>\n<pre><code>{\n    &quot;files&quot;: [\n        &quot;src/main.ts&quot;\n    ],\n    &quot;compilerOptions&quot;: {\n        &quot;noImplicitAny&quot;: true,\n        &quot;target&quot;: &quot;es5&quot;\n    }\n}\n</code></pre>\n<h3>配置 gulpfile.js 文件</h3>\n<p>在项目目录下建立 gulpfile.js 文件，来配置 gulp 命令</p>\n<blockquote>\n<p>目录/gulpfile.js 文件</p>\n</blockquote>\n<pre><code>var gulp = require(&quot;gulp&quot;);\nvar ts = require(&quot;gulp-typescript&quot;);\nvar tsProject = ts.createProject(&quot;tsconfig.json&quot;);\n\ngulp.task(&quot;default&quot;, function () {\n    return tsProject.src()\n        .pipe(tsProject())\n        .js.pipe(gulp.dest(&quot;dist&quot;));\n});\n</code></pre>\n<h3>运行 gulp 命令，查看效果</h3>\n<pre><code>gulp\n</code></pre>\n<ul>\n<li>gulp 命令通过 gulpfile.js 的配置，把 src/main.ts 编译成 dist/main.js 文件。\n此时在 dist 下会生成一个 main.js 文件，其文件的内容是：</li>\n</ul>\n<pre><code>function hello(compiler) {\n    console.log(&quot;hello from &quot; + compiler);\n}\nhello(&quot;TypeScript&quot;);\n</code></pre>\n<p>你可以回过去对比看看<code>src/main.ts</code> 的内容和现在的 <code>dist/main.js</code> 的内容对比。接下来通过node 命令来执行我们生成的main.js文件。</p>\n<pre><code class=\"language-javascript\">node dist/main.js\n</code></pre>\n<ul>\n<li>node dist/main.js 命令是在 node 环境中执行 main.js</li>\n</ul>\n<p>以上是在 node 中执行 javascript，那如何把 javascript 放在浏览器中执行呢？\n其实你可以直接把这个 main.js 引入到你的 html 页面中。</p>\n<h2>通过gulp命令来编译多个ts文件</h2>\n<p>现实中的项目目录肯定会有很多个模块，表现在多个单纯的文件中。下面来尝试一下：</p>\n<p>共三步.</p>\n<h3>新建一个greet.ts 文件：</h3>\n<p>在<code>src/greet.ts</code> 中，具体的代码如下：</p>\n<pre><code>export function sayHello(name: string) {\n    return `Hello from ${name}`;\n}\n</code></pre>\n<h3>在src/main.ts 代码引入 greet.ts</h3>\n<p>修改src/main.ts文件如下：</p>\n<pre><code>import { sayHello } from &quot;./greet&quot;;\nconsole.log(sayHello(&quot;TypeScript&quot;));\n</code></pre>\n<h3>将 src/greet.ts 添加到 tsconfig.json</h3>\n<pre><code>{\n    &quot;files&quot;: [\n        &quot;src/main.ts&quot;,\n        &quot;src/greet.ts&quot;\n    ],\n    &quot;compilerOptions&quot;: {\n        &quot;noImplicitAny&quot;: true,\n        &quot;target&quot;: &quot;es5&quot;\n    }\n}\n</code></pre>\n<p>注意：files 的值是一个数组，数组中最后一个元素不要加“,”。如果你加了，有可能会在接下来的任务中出错。</p>\n<h3>运行gulp命令，对main.js进行编译</h3>\n<p>确保执行 gulp 后模块是能工作的，在 Node.js 下进行测试：</p>\n<pre><code>gulp\nnode dist/main.js\n</code></pre>\n<p>你会得到如下：\ndist/main.js</p>\n<pre><code>&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;__esModule&quot;, { value: true });\nvar greet_1 = require(&quot;./greet&quot;);\nconsole.log(greet_1.sayHello(&quot;Typescript&quot;));\n\n</code></pre>\n<p>dist/greet.js</p>\n<pre><code>&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;__esModule&quot;, { value: true });\nfunction sayHello(name) {\n    return &quot;Hello from &quot; + name;\n}\nexports.sayHello = sayHello;\n</code></pre>\n<p>注意，此时，你如果直接在.html 文件中引用 dist/main.js 文件是会出错误的。原因是：浏览器中不认识 require 命令。 而在 node 环境是可以执行 node main.js 的，因为 node 支持 commonJS 的模块化。</p>\n<p>我们来证明这一点。</p>\n<h2>在浏览器环境中使用 main.js</h2>\n<h3>创建 src/index.html 文件</h3>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p id=&quot;greeting&quot;&gt;loading....&lt;/p&gt;\n    &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>从 src 目录中拷贝index.htm到 dist 目录</h3>\n<p>为什么不直接在 dist 目录下创建这个 index.html 文件，而非要在 src 目录下创建好了再复制过去呢？ 因为 src 是源目录，dist 是生产目录，我们只能把代码写在源目录中。</p>\n<p>这个拷贝的过程是通过建立 gulp 任务来完成的</p>\n<pre><code>let gulp = require(&quot;gulp&quot;)\n\nlet ts = require(&quot;gulp-typescript&quot;)\nlet tsProject = ts.createProject(&quot;tsconfig.json&quot;);\n\nlet paths = {\n    pages:[&quot;src/*.html&quot;]\n}\ngulp.task(&quot;copy-html&quot;,function(){\n    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))\n});\n\ngulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,function(){\n    return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(&quot;dist&quot;))\n}))\n</code></pre>\n<p>这里增加了 copy-html 任务并且把它加作 default 的依赖项。 这样，当 default 执行时，copy-html 会被首先执行。</p>\n<p>注意：default 是默认任务，而第二个参数 gulp.series()这种写法是 gulp4.0 的写法。gulp3.0 的写法有个一点小区别。请大家根据自己 gulp 的版本来决定。</p>\n<p>改造完 gulpfile.js 后，再次运行</p>\n<pre><code>gulp\n</code></pre>\n<p>可以看这个两个任务的结果:</p>\n<ol>\n<li>index.html 拷贝到了 dist 目录</li>\n<li>main.ts,greet.ts 被编译成了对应的.js 文件。</li>\n</ol>\n<h3>浏览器中的 export 错误</h3>\n<p>此时，我们通过浏览器打开 index.html 文件，你会在浏览器中看到错误信息：</p>\n<pre><code>main.js:2 Uncaught ReferenceError: exports is not defined\n    at main.js:2\n</code></pre>\n<p>那么，如何解决呢？</p>\n<h2>工程由 Node.js 环境移到浏览器环境里</h2>\n<p>现在，让我们把这个工程由 Node.js 环境移到浏览器环境里。 通过 Browserify 把所有模块捆绑成一个 JavaScript 文件。</p>\n<h3>安装依赖</h3>\n<pre><code>npm install --save-dev browserify tsify vinyl-source-stream\n</code></pre>\n<p>首先，安装 Browserify，tsify 和 vinyl-source-stream。 tsify 是 Browserify 的一个插件，就像 gulp-typescript 一样，它能够访问 TypeScript 编译器。 vinyl-source-stream 会将 Browserify 的输出文件适配成 gulp 能够解析的格式，它叫做 vinyl。</p>\n<h3>修改 gulpfile.js 配置</h3>\n<p>几个要点：</p>\n<ol>\n<li>使用 browserify 处理 typescript 文件的插件 tsify 来代替 gulp-typescript</li>\n<li>配置 browserify()打包.js 文件到 bundle.js</li>\n</ol>\n<pre><code>let gulp = require(&quot;gulp&quot;)\n\nlet browserify =require(&quot;browserify&quot;)\nlet source = require(&quot;vinyl-source-stream&quot;)\nlet tsify = require(&quot;tsify&quot;);\n\n// let ts = require(&quot;gulp-typescript&quot;)\n// let tsProject = ts.createProject(&quot;tsconfig.json&quot;);\n\nlet paths = {\n    pages:[&quot;src/*.html&quot;]\n}\ngulp.task(&quot;copy-html&quot;,function(){\n    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))\n});\n\ngulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,function(){\n    return browserify({\n        basedir:&quot;&quot;,\n        debug:true,\n        entries:[&quot;src/main.ts&quot;],\n        cache:{},\n        packageCache:{}\n    }).plugin(tsify)\n    .bundle()\n    .pipe(source('bundle.js'))\n    .pipe(gulp.dest(&quot;dist&quot;));\n}))\n</code></pre>\n<p>修改了 default 任务，让它使用 tsify 插件调用 Browserify，而不是 gulp-typescript。 方便的是，两者传递相同的参数对象到 TypeScript 编译器。</p>\n<p>调用 bundle 后，我们使用 source（vinyl-source-stream 的别名）把输出文件命名为 bundle.js。</p>\n<p>注意，我们为 Broswerify 指定了 debug: true。 这会让 tsify 在输出文件里生成 source maps。 source maps 允许我们在浏览器中直接调试 TypeScript 源码，而不是在合并后的 JavaScript 文件上调试。 你要打开调试器并在 main.ts 里打一个断点，看看 source maps 是否能工作。 当你刷新页面时，代码会停在断点处，从而你就能够调试 greet.ts。</p>\n<ol start=\"3\">\n<li>修改 src/index.html 中的的 js 文件引用</li>\n</ol>\n<p>此时，应该引用 ./boundle.js</p>\n<ol start=\"4\">\n<li>运行命令 gulp</li>\n</ol>\n<pre><code>gulp\n</code></pre>\n<ol start=\"5\">\n<li>观察./dist/bundle.js</li>\n</ol>\n<p>bundle.js</p>\n<pre><code>(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module '&quot;+i+&quot;'&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;__esModule&quot;, { value: true });\nfunction sayHello(name) {\n    return &quot;Hello from &quot; + name;\n}\nexports.sayHello = sayHello;\n},{}],2:[function(require,module,exports){\n&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;__esModule&quot;, { value: true });\nvar greet_1 = require(&quot;./greet&quot;);\nconsole.log(greet_1.sayHello(&quot;Typescript&quot;));\n},{&quot;./greet&quot;:1}]},{},[2])\n\n</code></pre>\n<ol start=\"6\">\n<li>打开 dist/index.html 文件\n你应该可以在控制台中看到正确的输出了。</li>\n</ol>\n<h2>自动构建</h2>\n<p>如果希望在编辑保存.ts 时，能立即在浏览器看到效果，我们可以引入watchify来实现这一点。</p>\n<h4>安装 watchify 包</h4>\n<pre><code>npm install --save-dev watchify gulp-util\n</code></pre>\n<p>Watchify 启动 Gulp 并保持运行状态，当你保存文件时自动编译。 帮你进入到编辑-保存-刷新浏览器的循环中。</p>\n<h4>修改 gulpfile.js 配置</h4>\n<p>共有三处改变，但是需要你略微重构一下代码。</p>\n<p>(1) 将 browserify 实例包裹在 watchify 的调用里，控制生成的结果。\n(2) 调用 watchedBrowserify.on(&quot;update&quot;, bundle);，每次 TypeScript 文件改变时 Browserify 会执行 bundle 函数。\n(3) 调用 watchedBrowserify.on(&quot;log&quot;, gutil.log);将日志打印到控制台。</p>\n<p>(1)和(2)在一起意味着我们要将 browserify 调用移出 default 任务。 然后给函数起个名字，因为 Watchify 和 Gulp 都要调用它。 (3)是可选的，但是对于调试来讲很有用。</p>\n<p>修改之后的代码如下：</p>\n<pre><code>let gulp = require(&quot;gulp&quot;)\n\nlet browserify =require(&quot;browserify&quot;)\nlet source = require(&quot;vinyl-source-stream&quot;)\nlet tsify = require(&quot;tsify&quot;);\nlet watchify = require(&quot;watchify&quot;)\nlet gutil = require(&quot;gulp-util&quot;)\n\nvar wathchedBrowerify = watchify(browserify({\n    basedir:&quot;&quot;,\n    debug:true,\n    entries:[&quot;src/main.ts&quot;],\n    cache:{},\n    packageCache:{}\n})).plugin(tsify)\n\nlet paths = {\n    pages:[&quot;src/*.html&quot;]\n}\ngulp.task(&quot;copy-html&quot;,function(){\n    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))\n});\nfunction bundle(){\n    return wathchedBrowerify.bundle().pipe(source('bundle.js'))\n    .pipe(gulp.dest(&quot;dist&quot;));\n}\ngulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,bundle));\n\nwathchedBrowerify.on(&quot;update&quot;,bundle);\nwathchedBrowerify.on(&quot;log&quot;,gutil.log)\n</code></pre>\n<h2>浏览器自动刷新</h2>\n<h3>安装 live-server</h3>\n<p>live-server 与我们上面介绍的 typescript，gulp 都没有关系。 你只需要全局安装 live-server。然后进入 dist 目录，运行 live-server 即可看到效果。</p>\n<p>它的<a href=\"https://www.npmjs.com/package/live-server\">npm 地址</a></p>\n<pre><code>npm install -g live-server\ncd dist\nlive-server\n</code></pre>\n<h2>在 html 中使用 less</h2>\n<p>在写页面时，不可避免地要用到css预编译工具，以less为例进行介绍，大家也可以同理拓展到其它的语言中。基本步骤是：</p>\n<ul>\n<li>安装less包</li>\n<li>修改gulp配置文件</li>\n</ul>\n<h3>准备好目录</h3>\n<p>dist/css</p>\n<p>src/less</p>\n<h3>安装 gulp-less 包</h3>\n<p>由于我们的工程化使用gulp工具，所以直接本地安装gulp-less即可。</p>\n<pre><code>npm install gulp-less --dev\n</code></pre>\n<h3>修改 gulpfile 配置</h3>\n<p>把less转css的工作，写入gulp任务。</p>\n<pre><code>let gulp = require(&quot;gulp&quot;)\n\nlet browserify =require(&quot;browserify&quot;)\nlet source = require(&quot;vinyl-source-stream&quot;)\nlet tsify = require(&quot;tsify&quot;);\nlet watchify = require(&quot;watchify&quot;)\nlet gutil = require(&quot;gulp-util&quot;)\n\nconst less = require('gulp-less')\n\nvar wathchedBrowerify = watchify(browserify({\n    basedir:&quot;&quot;,\n    debug:true,\n    entries:[&quot;src/main.ts&quot;],\n    cache:{},\n    packageCache:{}\n})).plugin(tsify)\n\nlet paths = {\n    pages:[&quot;src/*.html&quot;]\n}\n\ngulp.task('less', function () {\n    return gulp.src('src/less/**/*.less')\n      .pipe(less())\n      .pipe(gulp.dest('dist/css'));\n  });\n\ngulp.task(&quot;copy-html&quot;,function(){\n    return gulp.src(paths.pages).pipe(gulp.dest(&quot;dist&quot;))\n});\nfunction bundle(){\n    return wathchedBrowerify.bundle().pipe(source('bundle.js'))\n    .pipe(gulp.dest(&quot;dist&quot;));\n}\ngulp.task(&quot;default&quot;,gulp.series(&quot;copy-html&quot;,&quot;less&quot;,bundle));\n\ngulp.watch(['src/less/*.less','src/index.html'], gulp.series('less','copy-html'));\n\nwathchedBrowerify.on(&quot;update&quot;,bundle);\nwathchedBrowerify.on(&quot;log&quot;,gutil.log)\n\n</code></pre>\n<h2>总结</h2>\n<p>至此，我们搭建一个可以写 ts 代码，并在浏览器环境中运行的开发环境。它可以</p>\n<ul>\n<li>即时编译ts代码</li>\n<li>浏览器自动刷新</li>\n<li>支持less</li>\n</ul>\n","date_time":"2019-04-16","id":"01","name":"搭建一个可以在浏览器中运行ts的环境","slug_name":"da-jian-yi-ge-ke-yi-zai-liu-lan-qi-zhong-yun-hang-ts-de-huan-jing","link_name":"01javascript-ru-men/01da-jian-yi-ge-ke-yi-zai-liu-lan-qi-zhong-yun-hang-ts-de-huan-jing.html","course_name":"javascript入门"},{"substr":"  如何去生成自己的 xxx-cli 命令\r\n\r\n   背景\r\n\r\n你积累了一些前端工程代码，希望这些工程代码能够复用。 比如说，为了学习使用 typescript，我们在本地使用 gulp,type","content":"<h1>如何去生成自己的 xxx-cli 命令</h1>\n<h2>背景</h2>\n<p>你积累了一些前端工程代码，希望这些工程代码能够复用。 比如说，为了学习使用 typescript，我们在本地使用 gulp,typescript,browerify,live-server 等工具搭建了一个学习环境。</p>\n<p>现在，你如果把这个学习环境提供给其他小伙伴使用？</p>\n<h2>如何复用代码</h2>\n<p>复用代码给出三个选择：</p>\n<ol>\n<li>纯文件分享。</li>\n</ol>\n<p>例如，共享在百度云中。下次要使用时，直接 copy 下来，改改目录名，工程名。</p>\n<ol start=\"2\">\n<li>npm 包。</li>\n</ol>\n<p>在创建好前端项目之后，通过 npm install XXX 的方式把代码拉下来，保存在 node_modules 中。通过 import 的方式使用代码。</p>\n<ol start=\"3\">\n<li>\n<p>npm-cli 命令行</p>\n<p>具体使用方式是：</p>\n</li>\n</ol>\n<pre><code>npm instill -g XXXX;\nXXXX 命令 参数\n</code></pre>\n<p>典型的代码有 vue-cli, @vue-cli create-react-app 等等。</p>\n<p>常见的 vue-cli, @vue-cli create-react-app 等等。这种方式好处在于允许用户做一定的交互选择，或者设置。 例如，你在通过 vue-cli 命令去创建项目时，还是允许用户去设置自己的项目名字，开发时使用的一些参数等等。</p>\n<p>显然，第三种方法更加的灵活：它不像第一，二种只是单纯的复制粘贴代码。</p>\n<h2>基本步骤</h2>\n<ol>\n<li>在 github 上创建代码库(下午以 my-cli 为例)。</li>\n<li>在本地以 npm 包的方式开发。</li>\n<li>开发完成后，打包上传到 npm。</li>\n<li>其他用户通过 npm install -g my-cli 的方式安装到本地。</li>\n<li>在本地运行 my-cli create ，来创建一个初始项目。</li>\n</ol>\n<h3>让你的项目支持命令行</h3>\n<ol>\n<li>在 package.json 中设置 bin 选项。</li>\n</ol>\n<pre><code>{\n    &quot;bin&quot; : { &quot;my-cli&quot; : &quot;./cli.js&quot; }\n}\n</code></pre>\n<p>更多参考<a href=\"!https://docs.npmjs.com/files/package.json#bin\">bin</a> 。上面的<code>my-cli</code>就是我们后面要使用的命令的名字，这里，我故意把它设置成这个包的名字。</p>\n<ol start=\"2\">\n<li>创建 bin/cli.js 文件</li>\n</ol>\n<p>在项目根目录下，创建 bin/cli.js 文件。其中，目录结构如下：</p>\n<pre><code>my-cli\n    -bin\n        -cli.js\n    -package.json\n</code></pre>\n<ol start=\"3\">\n<li>编写 bin/cli.js 中的代码如下：</li>\n</ol>\n<pre><code>#!/usr/bin/env node\nconsole.info(&quot;hello my-cli !&quot;)\n</code></pre>\n<p>特别注意第一句： <code>#!/usr/bin/env node</code></p>\n<ol start=\"4\">\n<li>本地加载这个包\n在项目目录下运行 <code>npm install -g</code> , 这样就可以直接把这个包全局安装在本地了。</li>\n</ol>\n<pre><code> npm install -g\n</code></pre>\n<p>切换到其他的目录下。你试着在控制台中运行：</p>\n<pre><code>my-cli\n</code></pre>\n<p>就会看到控制台的输出了。</p>\n<p>为啥？\n我们知道，如果在控制台中直接输入 my-cli 还不报错，说明，my-cli 已经写入了环境目录下。在控制台中运行 <code>set</code> 命令，查看当前的环境变量。\n你会发现<code>C:\\Users\\用户名\\AppData\\Roaming\\npm</code>这个路径存在于环境变中。这就意味着你在控制台中输入的命令名，会在这个目录中去找，我们设置了<code>bin</code>这个属性，所以在全局安装时，已经加入了这个<code>my-cli</code>命令在环境变量所指向的目录中。这就是为什么你可以在控制台中直接输入<code>my-cli</code>命令来调用<code>my-cli/bin/cli.js</code> 文件了。</p>\n<p>接下来，就需要我们在 cli.js 中具体来做一些工作了。</p>\n","date_time":"2019-04-16","id":"02","name":"创建npm命令行工具","slug_name":"chuang-jian-npm-ming-ling-hang-gong-ju","link_name":"01javascript-ru-men/02chuang-jian-npm-ming-ling-hang-gong-ju.html","course_name":"javascript入门"},{"substr":"  跨域详解\r\n\r\n[[toc]]\r\n\r\n   什么是跨域\r\n\r\n如下的错误图片，会让你有印象吧。\r\n\r\n   什么时候会出现跨域请求的相关错误\r\n\r\n同时满足如下三个条件;\r\n\r\n1. 这个请求确实","content":"<h1>跨域详解</h1>\n<p>[[toc]]</p>\n<h2>什么是跨域</h2>\n<p>如下的错误图片，会让你有印象吧。</p>\n<h2>什么时候会出现跨域请求的相关错误</h2>\n<p>同时满足如下三个条件;</p>\n<ol>\n<li>这个请求确实是跨域了。</li>\n<li>你的浏览器'多管闲事'了。</li>\n<li>这个请求的类型是 xhr（xmlhttprequest）。</li>\n</ol>\n<h3>条件 1：请求是跨域</h3>\n<p>这种场合很多,典型的前后端分离的开发大多使用单独部署上线前端和后端，这时，前端与后端肯定不在一个域中。</p>\n<h3>条件 2：你的浏览器<code>多管闲事</code>了</h3>\n<p>浏览器会遵守<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a> 。 抱歉，我不应该使用<code>多管闲事</code>这个贬义词的。因为:</p>\n<blockquote>\n<p>&quot;同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&quot;</p>\n</blockquote>\n<p>我们也可以通过安装浏览器插件来决定是否让浏览器关闭同源策略检查，从而达到在<code>本机</code>可以跨域请求的目的。\n如 chrome 浏览器中的插件：</p>\n<p><img src=\"./assets/chromepluge.png\" alt=\"插件\"></p>\n<h3>条件 3：请求的类型是 xhr</h3>\n<p>网页中的很多标签都会请求外部的资源。当我们访问 baidu 的主页时，会看到类似的请求：</p>\n<p><img src=\".assets/requestype.png\" alt=\"请求类型\"></p>\n<p>其中对各种类型的图片，css 文件，js 文件的请求都是跨域的，但它们的类型都不是<code>xhr</code>。而只有类型是 xhr 的请求，才可能会遇到跨域的问题。</p>\n<h2>解决跨域问题的思路</h2>\n<p>如上述，产生跨域问题肯定是同时满足了如上三个条件，那么，我们只需破坏掉一些条件即可。</p>\n<ol>\n<li>请求是跨域</li>\n</ol>\n<ul>\n<li>思路： 让请求不要跨域</li>\n<li>方案： 代理请求。在本地也启动一个服务器，在收到本域的请求，把这个请求转发到目标服务器。</li>\n</ul>\n<ol start=\"2\">\n<li>浏览器<code>多管闲事</code></li>\n</ol>\n<ul>\n<li>通过配置浏览器，或者安装插件，让本机浏览器不需要遵守同源策略</li>\n<li>方案：不可行。客户在使用自己的机器，自己的浏览器，你不可能要求客户都去安装插件。</li>\n</ul>\n<ol start=\"3\">\n<li>请求是 xhr</li>\n</ol>\n<ul>\n<li>思路： 让请求类型不要是 xhr 的</li>\n<li>方案：jsonp</li>\n</ul>\n<p>还有：</p>\n<ol start=\"4\">\n<li><a href=\"!https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">cors</a></li>\n</ol>\n<h2>解决跨域问题</h2>\n<p>下面，我将从一个基本的场景出发，我们会一路遇到各种 error，并一路解决 error。</p>\n<blockquote>\n<p>access to xmlhttprequest at XXXX from orgin YYYY has been blocked by CORS policy: NO 'Access-Control-Allow-Origin' header is present on the requested resource</p>\n</blockquote>\n<p>以上错误解释起来是: 你从 YYYY 这个域(或者是接口什么的)向 XXXX(另一个域,或者是接口什么的)发起了 XMLHTTPRequest 请求，结果被<code>墙</code>(blocked)了，因为有 CORS policy。具体原因是：你请求的 XXXX 这个接口的并没有提供'Access-Control-Allow-Origin'信息。</p>\n<p>给你一个例子，回忆一下：</p>\n<p><img src=\"./img/basicerror.png\" alt=\"入门级错误\"></p>\n<p>我们先写一些代码，以复现这个问题。前端是：jquery 的 ajax,后端是 node express。\n你可以在这里找到<a href=\"!https://github.com/fanyoufu/testcors/tree/2postparam\">代码</a></p>\n<p>前端代码</p>\n<pre><code>const baseUrl = 'http://localhost:3000'\nvar data = null\n$.ajax({ url: baseUrl + '/get', type: 'get' }).then(rs =&gt; {\n   data = rs\n})\n</code></pre>\n<p>后端代码</p>\n<pre><code>var express = require('express')\nvar app = express()\napp.get('/get', function(req, res) {\n  res.json({ data: 'ok' })\n  console.log('/get .....')\n})\napp.listen(3000)\n</code></pre>\n<p>你分别启动前端（通过静态 http 服务器去打开网页，不是双击直接打开）和后端的 node 代码。 你就会发项这个错误已经在控制台中等着你了。下面，我们一起来解决这个问题。</p>\n<h3>区别简单请求和非简单请求</h3>\n<p>以下内容摘自<a href=\"!http://www.ruanyifeng.com/blog/2016/04/cors.html\">阮一峰的博客</a></p>\n<pre><code>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n\n（1) 请求方法是以下三种方法之一：\n\nHEAD\nGET\nPOST\n（2）HTTP的头信息不超出以下几种字段：\n\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n凡是不同时满足上面两个条件，就属于非简单请求。\n\n</code></pre>\n<h3>简单请求的处理</h3>\n<p>如下，就是一个标准的简单请求</p>\n<pre><code>const baseUrl = 'http://localhost:3000'\nvar data = null\n$.ajax({ url: baseUrl + '/get', type: 'get' }).then(rs =&gt; {\n   data = rs\n})\n</code></pre>\n<p>在向http://localhost:3000/get发请求时，浏览器会自动加上一个特殊的字段<code>Origin</code>在请求头中。</p>\n<pre><code>Origin: 当前发出当前请求的网页的地址信息，例如：localhost:9090\n</code></pre>\n<p>这个相当于给这个请求打了一个特殊的标记，如果从目标服务器接口http://localhost:3000/get给回的响应信息头中，没有'Access-Control-Allow-Origin'字段，或者其中的值不包含<code>当前发出当前请求的网页的地址信息</code>则报错误。</p>\n<blockquote>\n<p>access to xmlhttprequest at XXXX from orgin YYYY has been blocked by CORS policy: NO 'Access-Control-Allow-Origin' header is present on the requested resource</p>\n</blockquote>\n<p>解决办法是在服务器端的响应中设置这个字段。在 express 中，我们通过 res.header 去设置即可。</p>\n<pre><code>app.get('/get', function(req, res) {\n  res.header('Access-Control-Allow-Origin', '*') // 或者是全匹配 http://localhost:9090\n  res.json({ data: 'ok' })\n  console.log('/get .....')\n})\n</code></pre>\n<p>以上*可以理解为通配符，表示全部的来源都 Ok 的，你也可以写成某个具体的来源，例如'http://localhost:9090'，当然，这就表示服务器的/get接口只支持这个地址的来的跨域请求，如果你从其他的端口发请求过来，同样会报错。</p>\n<p>问题： 在浏览器报了这个错误，那么服务器端是否收到了请求呢？</p>\n<p>答案是：服务器端收到了。你可以通过观察 node 端的输出来看，确实输出了 这个日志信息：&quot;/get....&quot; 。也就是说请求从浏览器发出来，服务器也处理了，并给了返回值，整个过程的状态是正常的。但是，浏览器自己在收到返回值信息时，一检查，发现头信息少了东西，给报错了。</p>\n<h3>非简单请求</h3>\n<p>如果这个请求的类型是非简单请求，则整个过程要分成两步：</p>\n<ol>\n<li>发出预检命令。</li>\n<li>如果预检命令通过了，发出真实的命令。</li>\n</ol>\n<h4>示例</h4>\n<p>我们设置一个特殊的 contentType，它的值是 'application/json',根据我们上面的定义，此时的请求类型就是一个非简单请求了。</p>\n<p>前端加一个 post 请求</p>\n<pre><code>const baseUrl = 'http://localhost:3000'\nvar data = null\n $.ajax({url: baseUrl + '/post1',\n         type: 'post'\n       }).then(rs =&gt; {\n            data = rs\n          })\n</code></pre>\n<p>后端代码：</p>\n<pre><code>app.post('/post1', function(req, res) {\n  res.header('Access-Control-Allow-Origin', '*') // http://sps.ls.jd.com:8080 http://localhost:8080\n  res.json({ data: 'ok' })\n  // console.log('/post .....')\n})\n</code></pre>\n<p>同前面的分析，由于这一个简单请求，我们只需要在服务器端设置 acccess-control-allow-orgin 就可以了。</p>\n<p>下面，改成非简单请求。设置 contentType 值是 application/json</p>\n<pre><code>const baseUrl = 'http://localhost:3000'\nvar data = null\n $.ajax({\n \turl: baseUrl + '/post1',\n \tcontentType: 'application/json',\n    type: 'post'\n }).then(rs =&gt; {\n            data = rs\n          })\n</code></pre>\n<p>保持后端代码不变，此时，你会遇到问题：</p>\n<pre><code>jquery-3.3.1.min.js:2 OPTIONS http://localhost:3000/post1 net::ERR_CONNECTION_REFUSED\n</code></pre>\n<p>原因是非简单请求会先发出一个类型为 OPTIONS 的请求（预检命令），当这个请求被正确处理之后，才会发出真正的请求。现在出错误的原因是在服务器端没有配置这个接口相应。下面，我们在服务器端补充一个响应：</p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.end()\n})\n</code></pre>\n<p>此时会得到另一个错误:</p>\n<pre><code>Access to XMLHttpRequest at 'http://localhost:3000/post1' from origin 'http://127.0.0.1:9090' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n</code></pre>\n<p>同时，可以在 network 面板中看到：</p>\n<p><img src=\".assets/options.png\" alt=\"options类型的请求\"></p>\n<p>说明，确实是发出了一个类型为 options 的请求。接下来，我们回过头来处理这个错误。上面的这个错误看起来非常眼熟嘛，我们按照上面的解决方案：给 res 设置 header 处理。</p>\n<p>修改 options 响应如下：</p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.header('Access-Control-Allow-Origin', '*')\n  res.end()\n})\n</code></pre>\n<p>再访问，你会遇到一个新的错误信息，是有关<code>Access-Control-Allow-Headers</code>的：</p>\n<pre><code>Access to XMLHttpRequest at 'http://localhost:3000/post1' from origin 'http://127.0.0.1:9090' has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response.\n</code></pre>\n<p>意思是你在 ajax 请求中设置了 contentType: 'application/json',但是，现在收到的响应头中却没有找到 content-type 这个信息。 ok，我们在 options 响应中补上一句：</p>\n<blockquote>\n<p>res.header('Access-Control-Allow-Headers', 'Content-Type')</p>\n</blockquote>\n<p>整体的代码如下：</p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.header('Access-Control-Allow-Origin', '*')\n  res.header('Access-Control-Allow-Headers', 'Content-Type'); //新加的\n  res.end()\n})\n\napp.post('/post1', function(req, res) {\n  res.header('Access-Control-Allow-Origin', '*')\n\n  res.json({ data: 'ok' })\n  console.log('/post .....')\n})\n</code></pre>\n<p>到此为止，我们终于成功了。\n<img src=\".assets/optionsandpost.png\" alt=\"先optioins再post\"></p>\n<p>总结一下，非简单请求会发两次请求，先是 options，再是真正的请求。 你可能会想了，为啥要发两次，为啥每次都要发两次？</p>\n<h3>指定本次预检请求的有效期</h3>\n<p><code>Access-Control-Max-Age</code>该字段可选，用来指定本次预检请求的有效期，单位为秒。在此期间，不用发出另一条预检请求。</p>\n<p>我们添加一条设置<code>res.header('Access-Control-Max-Age', '3600')</code>在一个小时内不重复发预检指令。</p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.header('Access-Control-Max-Age', '3600')\n  res.header('Access-Control-Allow-Origin', '*') // http://sps.ls.jd.com:8080 http://localhost:8080\n  res.header('Access-Control-Allow-Headers', 'Content-Type')\n\n  res.end()\n})\n</code></pre>\n<p>然后，你应该可以发现 options 不见了，现在只有一条请求了。注意：控制面板中的<code>disable cache</code>开关可以帮助你观察这个细节。\n<img src=\"./img/optionscache.png\" alt=\"缓存预检指令\"></p>\n<h3>设置特殊的请求头</h3>\n<p>在上例的基础上，我们设置一个自定义的 header</p>\n<pre><code>$.ajax({\n            contentType: 'application/json',\n            headers: {\n              header1: 'AAA'\n            },\n            url: baseUrl + '/post1',\n            type: 'post'\n          }).then(rs =&gt; {\n            data = rs\n          })\n</code></pre>\n<p>你会得到一个新的错误，如下：</p>\n<pre><code>Access to XMLHttpRequest at 'http://localhost:3000/post1' from origin 'http://127.0.0.1:9090' has been blocked by CORS policy: Request header field header1 is not allowed by Access-Control-Allow-Headers in preflight response.\n</code></pre>\n<p>解决办法类似：少什么，就加什么。如下，我们把 header1 加入到<code>Access-Control-Allow-Headers</code>字段中即可：</p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.header('Access-Control-Max-Age', '3600')\n  res.header('Access-Control-Allow-Origin', '*') // http://sps.ls.jd.com:8080 http://localhost:8080\n  res.header('Access-Control-Allow-Headers', 'Content-Type,header1')\n\n  res.end()\n})\n</code></pre>\n<h3>带 cookie</h3>\n<p>让 ajax 请求带上 cookie,需要设置 xhrFields:{withCredentials:true} 。我们加上这句之后，如下：</p>\n<pre><code>$.ajax({\n    contentType: 'application/json',\n    headers: {\n      header1: 'AAA'\n    },\n    xhrFields: {\n      withCredentials: true\n    },\n    url: baseUrl + '/post1',\n    type: 'post'\n  }).then(rs =&gt; {\n    data = rs\n  })\n</code></pre>\n<p>现在又有一个新的错误：</p>\n<pre><code>Access to XMLHttpRequest at 'http://localhost:3000/post1' from origin 'http://127.0.0.1:9090' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.\n</code></pre>\n<p>错误的意思是指由于使用了 cookie，这里的 <code>Access-Control-Allow-Origi</code>值不能是*, 而并是具体的地址。所以我们改成如下：</p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.header('Access-Control-Max-Age', '3600')\n  res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:9090')\n  res.header('Access-Control-Allow-Headers', 'Content-Type,header1')\n  res.end()\n})\n</code></pre>\n<p>再错</p>\n<pre><code>Access to XMLHttpRequest at 'http://localhost:3000/post1' from origin 'http://127.0.0.1:9090' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.\n</code></pre>\n<p>再加一句<code>res.header('Access-Control-Allow-Credentials', true)</code></p>\n<pre><code>app.options('/post1', function(req, res) {\n  res.header('Access-Control-Max-Age', '3600')\n  res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:9090') // http://sps.ls.jd.com:8080 http://localhost:8080\n  res.header('Access-Control-Allow-Headers', 'Content-Type,header1')\n  res.header('Access-Control-Allow-Credentials', true)\n\n  res.end()\n})\n</code></pre>\n","date_time":"2019-04-24","id":"03","name":"跨域详解","slug_name":"kua-yu-xiang-jie","link_name":"01javascript-ru-men/03kua-yu-xiang-jie.html","course_name":"javascript入门"},{"substr":"模块化发展历程\r\n\r\n- 第一个级别\r\n- 第二个级别\r\n- commonJS\r\n- amd 0\r\n- ES6 中的模块化\r\n","content":"<p>模块化发展历程</p>\n<ul>\n<li>第一个级别</li>\n<li>第二个级别</li>\n<li>commonJS</li>\n<li>amd 0</li>\n<li>ES6 中的模块化</li>\n</ul>\n","date_time":"","id":"04","name":"模块化发展历程","slug_name":"mo-kuai-hua-fa-zhan-li-cheng","link_name":"01javascript-ru-men/04mo-kuai-hua-fa-zhan-li-cheng.html","course_name":"javascript入门"},{"substr":"  三种常见的 POST 提交数据方式对应的 content-type 取值\r\n\r\najax 的用来从浏览器发送异步请求到服务器端，并根据返回值对页面进行局部更新。当然，在它访问服务器接口时，它也可以","content":"<h1>三种常见的 POST 提交数据方式对应的 content-type 取值</h1>\n<p>ajax 的用来从浏览器发送异步请求到服务器端，并根据返回值对页面进行局部更新。当然，在它访问服务器接口时，它也可以携带数据的，例如：用户注册时，要带上用户名和邮箱信息；用户发布留言时，要带上留言的内容等。 本文主要讨论如何去携带这些信息，及对应地在后端代码中如何去获取携带的数据。</p>\n<h2>application/x-www-form-urlencoded</h2>\n<p>你可以在开发者工具的 network 面板中的观察 <code>content-type：application/x-www-form-urlencoded</code>，它传参时，可以看到请求体中的关键字：<code>Form Data</code></p>\n<p><img src=\"assets/1559566184130.png\" alt=\"1559566184130\"></p>\n<h3>原生 ajax 中使用</h3>\n<p>使用原生 ajax 时，通过 post 方式发送请求时要主动设置加上这一句。虽然现在很人使用原生 ajax 了，不过自己当作学习写写也不错的。</p>\n<pre><code class=\"language-javascript\">var xhr = new XMLHttpRequest();\nxhr.open('post', 'common/post');\nxhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\nxhr.send(`userName=${userName}&amp;userPassword=${userPassword}`);\nxhr.onload = function() {\n  console.info(xhr.response);\n};\n</code></pre>\n<h3>$.ajax 中使用</h3>\n<p>如果你使用 jQuery 中提供了 ajax 相关方法时，则它的默认 content-type 就是这个<code>application/x-www-form-urlencoded</code>。所以，在你使用$.post 时，并不需要特别的设置。</p>\n<h2>application/json</h2>\n<p>如果你要传递的只是普通的键值对数据，例如:</p>\n<pre><code class=\"language-javascript\">$.ajax({\n  url: './common/post',\n  type: 'post',\n  data: { name: 'jake', age: 30 }\n});\n</code></pre>\n<p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>\n<p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。</p>\n<p>著名的第三方库<code>axios</code> 在使用 post 请求时，默认设置 content-type 就是这个值。</p>\n<p><img src=\"assets/1559566728597.png\" alt=\"1559566728597\"></p>\n<p>它适合于传递比较复杂的，多级嵌套的 json 数据。</p>\n<h2>multipart/form-data：</h2>\n<p>multipart/form-data 是指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思。用于文件上传时。</p>\n<p><img src=\"assets/1559566471039.png\" alt=\"1559566471039\"></p>\n<ul>\n<li>使用 &lt;form&gt; 标签，并手动设置 enctype 属性。</li>\n<li>通过 FormData()来构造传参</li>\n<li>如果是通过 jQuery.ajax 来使用 FormData()的话，还要注意，去掉默认的 content-type 以及不要处理数据。</li>\n</ul>\n<pre><code class=\"language-javascript\">$('#btn').click(function() {\n    // 收集用户信息\n    var fd = new FormData($('#myForm')[0]);\n    $.ajax({\n        url: 'common/post',\n        type: 'post',\n        data: fd,\n        processData: false, // 不需要jquery去处理数据。 （2）\n        contentType: false, // 不需要默认的contentType，而采用FormData自己的 （3）\n        success: function(res) {\n            console.info(res);\n        }\n    });\n</code></pre>\n<p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束</p>\n<p>如何你采用这种方式去传递数据到后端，则需要后端代码的特殊支持，至少在 node+express 环境下，你需要安装类似于</p>\n<pre><code>const multipart = require('connect-multiparty');\nvar multipartMiddleware = multipart();\n\nrouter.post('/post', multipartMiddleware, function(req, res) {\n\nlet d = Object.assign({}, req.body, {\n\n \\_t: Date.now(),\n\n str: '服务器返回成功'\n\n});\n\nres.json(d);\n\n});\n</code></pre>\n<p>小结：</p>\n<p>从前端向后端传值是 一个非常普遍存在的应用场景，本文讨论了三种常见的post提交数据使用的content-type，希望对你有帮助。</p>\n","date_time":"2019-06-03","id":"05","name":"提交数据与","slug_name":"ti-jiao-shu-ju-yu","link_name":"01javascript-ru-men/05ti-jiao-shu-ju-yu.html","course_name":"javascript入门"}],"target":"学习完成之后能达到的目标是什么","index_path":"01javascript-ru-men/index.html","basic":"你需要的一些基础知识是什么。"},{"cou_id":"02","name":"node","full_name":"02_node","slug_name":"node","article_list":[{"substr":"  如何在调试 node 代码\r\n\r\n   node 代码\r\n\r\n代码: `node --inspect index.js`\r\n\r\n.vscode 中会自动产生一个 launch.json 文件\r\n\r","content":"<h1>如何在调试 node 代码</h1>\n<h2>node 代码</h2>\n<p>代码: <code>node --inspect index.js</code></p>\n<p>.vscode 中会自动产生一个 launch.json 文件</p>\n<pre><code>{\n    // 使用 IntelliSense 了解相关属性。\n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    &quot;version&quot;: &quot;0.2.0&quot;,\n    &quot;configurations&quot;: [\n        {\n            &quot;type&quot;: &quot;node&quot;,\n            &quot;request&quot;: &quot;launch&quot;,\n            &quot;name&quot;: &quot;启动程序&quot;,\n            &quot;program&quot;: &quot;${workspaceFolder}/index.js&quot;\n        }\n    ]\n}\n</code></pre>\n<p>加上断点，就可以在 vscode 的调试面板中查看效果了。</p>\n<h2>浏览器中调试</h2>\n<pre><code>node --inspect server.js\n</code></pre>\n<p>会输出</p>\n<pre><code>Debugger listening on ws://127.0.0.1:9229/845f1fd0-2ff2-45d6-bcfe-246b085700b1\nFor help see https://nodejs.org/en/docs/inspector\n</code></pre>\n<p>复制<code>127.0.0.1:9229/json</code>到浏览器中,可以看到如下：</p>\n<pre><code>[ {\n  &quot;description&quot;: &quot;node.js instance&quot;,\n  &quot;devtoolsFrontendUrl&quot;: &quot;chrome-devtools://devtools/bundled/inspector.html?experiments=true&amp;v8only=true&amp;ws=127.0.0.1:9229/845f1fd0-2ff2-45d6-bcfe-246b085700b1&quot;,\n  &quot;faviconUrl&quot;: &quot;https://nodejs.org/static/favicon.ico&quot;,\n  &quot;id&quot;: &quot;845f1fd0-2ff2-45d6-bcfe-246b085700b1&quot;,\n  &quot;title&quot;: &quot;server.js&quot;,\n  &quot;type&quot;: &quot;node&quot;,\n  &quot;url&quot;: &quot;file:///Users/fanyoufu/传智播客/fanyoufu/01-ajax/代码/nativeServer/server.js&quot;,\n  &quot;webSocketDebuggerUrl&quot;: &quot;ws://127.0.0.1:9229/845f1fd0-2ff2-45d6-bcfe-246b085700b1&quot;\n} ]\n</code></pre>\n<p>两种方式去开始浏览器中调试：</p>\n<ul>\n<li>\n<p>直接在浏览器中输入：chrome://inspect/#devices\n可能需要去端口与 ip 地址进行配置了。</p>\n</li>\n<li>\n<p>上面的 json 中 chrome-devtools 复制，直接在浏览器中输入。\n在 sources 中，你可能什么也看不到，不要紧，通过 open 命令，输入在 node 中写的文件名，再回车，你就可以看到你的 node 中的文件了。然后，正常通过 chrome 浏览器进行调试。</p>\n</li>\n</ul>\n","date_time":"2019-06-09","id":"01","name":"如何在node环境中调试代码","slug_name":"ru-he-zai-node-huan-jing-zhong-tiao-shi-dai-ma","link_name":"02node/01ru-he-zai-node-huan-jing-zhong-tiao-shi-dai-ma.html","course_name":"node"}],"target":"学习完成之后能达到的目标是什么","index_path":"02node/index.html","basic":"你需要的一些基础知识是什么。"},{"cou_id":"03","name":"前端开发工具tools","full_name":"03_前端开发工具tools","slug_name":"qian-duan-kai-fa-gong-ju-tools","article_list":[{"substr":"  将 VSCode 设置成中文语言环境\r\n\r\n初始安装时，使用的是英文包，所以界面菜单全是英文的。如果你想使用中文环境，可以以安装插件的方式去安装中文语言包。\r\n\r\n步骤如如下：\r\n\r\n1. 进入拓","content":"<h1>将 VSCode 设置成中文语言环境</h1>\n<p>初始安装时，使用的是英文包，所以界面菜单全是英文的。如果你想使用中文环境，可以以安装插件的方式去安装中文语言包。</p>\n<p>步骤如如下：</p>\n<ol>\n<li>进入拓展安装</li>\n<li>安装指定插件<code>chinese Language Pack for Visual Studio Code</code></li>\n</ol>\n<p><img src=\"assets/1559738384919.png\" alt=\"1559738384919\"></p>\n<ol start=\"3\">\n<li>\n<p>按要求重启 vscode。</p>\n</li>\n<li>\n<p>如果第三步没有起作用（或者后期你又想回到英文的操作环境） 你可以手动切换：</p>\n<p>（1）按键<code>ctrl+shift+p</code>,调出命令面板，输入“configure display language”，选中这个命令。</p>\n</li>\n</ol>\n<p><img src=\"assets/1559794365110.png\" alt=\"1559794365110\">\n（2）然后，在弹出的下拉列表中，选择你刚才安装的语言包 。</p>\n<p><img src=\"assets/1559794407419.png\" alt=\"1559794407419\"></p>\n<ol start=\"5\">\n<li>值得注意的是，如果你升级了 vscode，好像它会自动退回到英文语言包（这一点我并不确定），这里你只需要通过<code>configure display language</code>重新切换一次语言包就可以了。</li>\n</ol>\n","date_time":"2019-06-05","id":"01","name":"vscode常规设置","slug_name":"vscode-chang-gui-she-zhi","link_name":"03qian-duan-kai-fa-gong-ju-tools/01vscode-chang-gui-she-zhi.html","course_name":"前端开发工具tools"},{"substr":"  vscode格式化\r\n\r\n在写代码的过程中，整洁的，统一的格式会让代码更好读，也会减少出错的可能。所以，格式化是一个非常必须的功能。\r\n\r\n\r\n\r\n   内置的格式化功能\r\n\r\n对于常见的文件格式","content":"<h1>vscode格式化</h1>\n<p>在写代码的过程中，整洁的，统一的格式会让代码更好读，也会减少出错的可能。所以，格式化是一个非常必须的功能。</p>\n<h2>内置的格式化功能</h2>\n<p>对于常见的文件格式，vscode本身就有<code>简单格式化</code>的功能。以.html文件为例：</p>\n<pre><code class=\"language-HTML\">&lt;div class='container'&gt;\n    &lt;h1&gt;vscode自带格式化功能&lt;/h1&gt;\n&lt;div&gt;\n      右键-&gt;'格式化文档'\n&lt;/div&gt;\n    \n    \n    \n    &lt;p&gt;只能进行简单的格式化：如“缩进对齐”&lt;/p&gt;\n    &lt;p&gt;不能进行高级的格式化：如“去掉多余的空行”&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<p>对于如上代码，格式化时（右键-&gt;'格式化文档'），只能进行<code>缩进对齐</code>，而更高级的 <code>去掉多余的空行</code>就做不到了。</p>\n<p>同样，对于<code>.js</code>文件的格式化也有这个问题：它只能格式化，不能做更高级的功能，例如：提示你某个变量定义了，却没有使用。</p>\n<h2>保存时自动格式化</h2>\n<p>如果你不希望每次手动去格式化（右键-&gt;'格式化文档'），你也可以设置在保存时（按下<code>ctrl+s</code>）自动去格式化。要实现这一点，只需要去配置一下<code>设置</code>即可。</p>\n<p>步骤：</p>\n<ul>\n<li>快捷键<code>ctrl + ’</code> ，打开<code>设置</code>面板。vscode 及插件的设置全部集中在这里。</li>\n</ul>\n<p><img src=\"assets/1559799052834.png\" alt=\"1559799052834\"></p>\n<ul>\n<li>输入 format 关键字，以减少设置项的范围。找到<code>Format On Save</code>,打上勾就行了。</li>\n<li>关闭设置选项卡，回到你的代码中，修改一些格式，例如打乱标签的对齐方式。再按下<code>ctrl+s</code> ，看看是否就自己自动格式化了。</li>\n</ul>\n<p>设置选项卡中，我们可以做很多的设置工作，其基本操作流程就是：</p>\n<ul>\n<li>ctrl + ‘</li>\n<li>输入关键字搜索。当然，也可以在左侧的树状菜单中自己找。</li>\n<li>打上勾，或者是取消。</li>\n</ul>\n<p>这个操作会经常做，这里先提醒下。</p>\n<h2>理解<code>设置</code>选项卡</h2>\n<p>上面介绍的vscode的设置中，有一个注意事项：对vscode的设置有两个维度：</p>\n<p><img src=\"assets/1559799668043.png\" alt=\"1559799668043\"></p>\n<ul>\n<li>用户</li>\n<li>工作区</li>\n</ul>\n<h3>用户 设置</h3>\n<p>它是对整个用户设置，就是说只要当前这个用户在使用vscode就统一使用这个配置，而不限于某个项目。如果你在用户这个维度进行设置，则你所做的设置会生成一个配置文件，路径是<code>C:\\Users\\某用户名\\AppData\\Roaming\\Code\\User\\settings.json</code>（以win10为例）</p>\n<p><img src=\"assets/1559799914324.png\" alt=\"1559799914324\"></p>\n<p>（大概是这个位置，可能与操作系统有关。）</p>\n<h3>工作区 设置</h3>\n<p>这个设置只在当前工作区有效。对应会在本项目的根目录 下产生一个.vscode文件夹，下面有一个settings.json，其中就保存着你的配置。</p>\n<p><img src=\"assets/1559800326963.png\" alt=\"1559800326963\"></p>\n<p>如上所示的图中，表示开启了<code>保存时自动格式化</code> (editor.formatOnSaves)</p>\n<h3>修改json文件来更新设置</h3>\n<p>我们可以在图形化的界面中，通过鼠标进行操作来修改设置。</p>\n<p><img src=\"assets/1559800566615.png\" alt=\"显示了一个比较复杂的编辑\"></p>\n<p>如上图示精确格式化javascript代码的一些设置项。也标出了如何进入对应的settings.json文件。</p>\n<p>下面是一个setting.json的示例：</p>\n<pre><code class=\"language-json\">{\n    &quot;window.zoomLevel&quot;: 2,// 把窗口放大2倍。你通过ctrl + '+' 就可以设置。放大之后，字大一些。 \n    &quot;editor.formatOnSave&quot;: true, // 保存时自动格式化\n    &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,\n}\n</code></pre>\n<p>如果你不认识第三句，也不要紧，在vscode中，对setting.json有丰富的提示功能：</p>\n<p><img src=\"assets/1559801064085.png\" alt=\"1559801064085\"></p>\n<p>我们可以把他人定义好的配置文件中的内容复制过来，在自己的配置文件中使用。同时也可以把自己的配置方法放出来共其它人，或者是同事一起使用。</p>\n<h2>prettier格式化插件</h2>\n<p>如果你觉得vscode自带的格式化功能不够用，你也可以选择第三方的格式化插件。下面以prettier为例，进行介绍。</p>\n<p>当然 ，先是安装这个插件。</p>\n<h3>设置成默认工具</h3>\n<p>安装成功之后，你再次打开某个.html文件（注意是.html文件，而不是其它类型），右键，此时与格式化相关的命令中会多出一个<code>格式化文档，方法是用使用...</code></p>\n<p><img src=\"assets/1559801524539.png\" alt=\"1559801524539\"></p>\n<p>此时，由于vscode中有两个可以使用的格式工具：</p>\n<ul>\n<li>自带的</li>\n<li>prettier</li>\n</ul>\n<p>它就会聪明地问你，你要用哪一个？</p>\n<p>你点击这个命令，出现如下：</p>\n<p><img src=\"assets/1559801668573.png\" alt=\"1559801668573\"></p>\n<p>你可以自己选择一个。当然，自带的格式化与prettier插件提供的格式化还是有明显的区。 以如下html代码为例：</p>\n<pre><code class=\"language-html\">&lt;div&gt;\n    \n    \n    &lt;p&gt;\n      &lt;a&gt;&lt;/a&gt;\n    &lt;/p&gt;\n    \n    \n&lt;/div&gt;\n</code></pre>\n<p>以上代码有两处不符合格式：</p>\n<ol>\n<li>a标签没有正确缩进。这个问题两种格式化功能都能做。</li>\n<li>p标签前面有很多行空白行。这个问题自带的格式化功能就不能解决，而prettier可以<code>聪明地只保留前后各一个空行</code>，把其它的空行都删掉。</li>\n</ol>\n<p>如果你把prettier设置成默认的格式化工具，则在配置文件中就会多出如下：</p>\n<pre><code class=\"language-json\">{\n  &quot;window.zoomLevel&quot;: 2,\n  &quot;editor.formatOnSave&quot;: true,\n  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,\n  &quot;[html]&quot;: { // 把prettier设置成对html文件进行格式化的默认程序\n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n  }\n}\n</code></pre>\n<p>同样，如果你对.js文件也使用格式化命令，你看到的可能就是：</p>\n<p><img src=\"assets/1559802242682.png\" alt=\"1559802242682\"></p>\n<p>如果你也同样地选择prettier作为默认格式化工具，则在配置文件中就会再多出一条设置：</p>\n<pre><code class=\"language-json\">{\n  &quot;window.zoomLevel&quot;: 2,\n  &quot;editor.formatOnSave&quot;: true,\n  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,\n  &quot;[html]&quot;: {// 把prettier设置成对html文件进行格式化的默认程序\n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n  },\n  &quot;[javascript]&quot;: { // 把prettier设置成对js文件进行格式化的默认程序\n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n  }\n}\n</code></pre>\n<p>当然，如果你对prettier的格式化效果不满意，你也可以直接在settings.json中删除对应的项即可。同理，去使用其它 的格式化插件。</p>\n<h3>设置</h3>\n<p>.prettierrc</p>\n","date_time":"2019-06-06","id":"02","name":"vscode中的格式化","slug_name":"vscode-zhong-de-ge-shi-hua","link_name":"03qian-duan-kai-fa-gong-ju-tools/02vscode-zhong-de-ge-shi-hua.html","course_name":"前端开发工具tools"}],"target":"学习完成之后能达到的目标是什么","index_path":"03qian-duan-kai-fa-gong-ju-tools/index.html","basic":"你需要的一些基础知识是什么。"},{"cou_id":"04","name":"vue基础","full_name":"04_vue基础","slug_name":"vue-ji-chu","article_list":[{"substr":"   组件之间相互转递数据\r\n\r\n先要确定一点，数据是在哪里产生的？这个问题很关键，它是会直接影响我们如何去设计组件的结构。\r\n\r\n我建议的答案是：数据是从上级组件中产生，然后流向下级。举个例子：\r\n","content":"<h2>组件之间相互转递数据</h2>\n<p>先要确定一点，数据是在哪里产生的？这个问题很关键，它是会直接影响我们如何去设计组件的结构。</p>\n<p>我建议的答案是：数据是从上级组件中产生，然后流向下级。举个例子：</p>\n<pre><code>&lt;my-header&gt;\n    &lt;div&gt;\n        .....\n    &lt;/div&gt;\n    &lt;my-vator&gt;&lt;/my-vator&gt;\n&lt;/my-header&gt;\n</code></pre>\n<p>这里有一个组件的嵌套关系：my-header&gt; my-vator 。我们需要在 my-vator 上显示用户的头像，用户名等信息。 这是一个典型的应用场景，现在的问题是：数据（用户基本信息）是在哪个组件中产生的。</p>\n<ul>\n<li>A : 父级组件 my-header</li>\n<li>B : 子组件 my-vator</li>\n</ul>\n<p>如果选择 A, 意味着则 my-vator 组件就是一个纯用来展示信息的组件：给他什么信息，它就显示什么。它自己不能产生数据。</p>\n<p>如果选择 B, 意味着 my-vaotr 可以自己去发请求，去得到数据，显示数据，它完全是自给自足的。你把它放在任何的地方，它就可以自己独立的工作。</p>\n<p>看你决定怎么选择。 我选择 A： 一切数据都从父级组件中获取，子组件只是消费数据。</p>\n<table>\n<thead>\n<tr>\n<th>从</th>\n<th>哪里</th>\n<th>传递到</th>\n<th>是否改状态</th>\n<th>是否回传状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>父组件</td>\n<td>-&gt;子组件</td>\n<td>子组件内部不改状态</td>\n<td>否</td>\n</tr>\n<tr>\n<td>2</td>\n<td>父组件</td>\n<td>-&gt;子组件</td>\n<td>子组件内部改状态</td>\n<td>是</td>\n</tr>\n<tr>\n<td>3</td>\n<td>子组件</td>\n<td>-&gt;父组件</td>\n<td>子组件内部改状态</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<pre><code>&lt;div&gt;\n    &lt;son-component @myevent=&quot;hEvent&quot;&gt;&lt;/son-component&gt;\n&lt;/div&gt;\n\n\nVue.component(&quot;son-component&quot;, {\n    tempalte:&quot;&lt;div&gt;&lt;input v-model='msg'&gt;&lt;button @click='hClick'&gt;ok&lt;/button&gt;&lt;/div&gt;&quot;,\n    data:function(){\n        return {msg:&quot;init value&quot;}\n    },\n    methods:{\n        hClick(){\n            this.$emit(&quot;myevent&quot;,this.msg)\n        }\n    }\n})\n</code></pre>\n<p>$emit</p>\n","date_time":"2019-04-12","id":"01","name":"vue组件","slug_name":"vue-zu-jian","link_name":"04vue-ji-chu/01vue-zu-jian.html","course_name":"vue基础"},{"substr":" \r\n\r\n   服务器端渲染\r\n\r\n渲染是指把数据转成具体的dom节点的过程。你可以在两个地方进行这个操作：在服务器上，在客户端。\r\n\r\n    服务器端渲染\r\n\r\n    客户端渲染\r\n\r\n    ","content":"<h2>服务器端渲染</h2>\n<p>渲染是指把数据转成具体的dom节点的过程。你可以在两个地方进行这个操作：在服务器上，在客户端。</p>\n<h3>服务器端渲染</h3>\n<h3>客户端渲染</h3>\n<h3>优缺点</h3>\n<p>服务器端渲染：</p>\n<p>好处：</p>\n<p>对seo更友好；</p>\n<p>坏处：</p>\n<p>对服务器的压力更大</p>\n<h2>理解服务器渲染</h2>\n<p>把数据和视图渲染成html的过程在服务器上进行。这一点就是很久以前我们做网页的套路：php+smarty引擎。现在，又翻出来。</p>\n<p>下面的示例中，我们通过vue库和vue-server-renderer这个插件，来实现这个过程：</p>\n<ul>\n<li>用vue做视图</li>\n<li>用vue-server-renderer来把vue实例转成html代码片断。</li>\n</ul>\n<p>具体步骤如下：</p>\n<ol>\n<li>使用npm建立一个项目，并安装相关插件.</li>\n</ol>\n<p>新建一个文件夹，cmd进入到这个文件夹下，通过 <code>npm init --yes</code>进行初始化操作。</p>\n<p>安装依赖。这里以vue及<a href=\"https://ssr.vuejs.org/zh/api/#createrenderer\">vue-server-renderer</a>插件为例。</p>\n<p>（1） 第一步：安装vue</p>\n<p>（2） 第二步：安装vue-server-renderer插件</p>\n<ol start=\"2\">\n<li>新建立一个文件，名为index.js。其中代码如下：</li>\n</ol>\n<pre><code class=\"language-javascript\">const Vue = require('vue');\nconst renderer = require('vue-server-renderer').createRenderer();\n\nconst app = new Vue({\n  template: '&lt;h1&gt;hello world-{{name}}&lt;/h1&gt;',\n  data: () =&gt; {\n    return {\n      name: 'james'\n    };\n  }\n});\n\nrenderer.renderToString(app, (err, html) =&gt; {\n  if (err) {\n    console.log(err);\n    return;\n  }\n  console.log(html);\n});\n</code></pre>\n<ol start=\"3\">\n<li>测试效果</li>\n</ol>\n<p><code>node index.js</code></p>\n<p>你如果看到如下的输出;</p>\n<p><code>&lt;h1 data-server-rendered=&quot;true&quot;&gt;hello world-james&lt;/h1&gt;</code></p>\n<p>就表示，这个已经成功了:把一个vue实例的内容，转成了html字符串</p>\n<h2>一个完整的服务器渲染的例子</h2>\n<p>在上例的基础上，引入express来充当服务器框架，快速启动一个web服务器。具体代码如下：</p>\n<pre><code class=\"language-javascript\">const Vue = require('vue');\nconst renderer = require('vue-server-renderer').createRenderer();\nconst server = require('express')();\n\nserver.get('/index.html', (req, res) =&gt; {\n  renderer.renderToString(app, (err, html) =&gt; {\n    if (err) {\n      console.log(err);\n      return;\n    }\n    console.log(html);\n    res.end(`&lt;html&gt;&lt;body&gt;${html}&lt;/body&gt;&lt;/html&gt;`);\n  });\n});\nserver.listen(8081, function() {\n  console.log('http://localhost:8081/index.html');\n});\n\nconst app = new Vue({\n  template: '&lt;h1&gt;hello world-{{name}}&lt;/h1&gt;',\n  data: () =&gt; {\n    return {\n      name: 'james'\n    };\n  }\n});\n\n</code></pre>\n<ol>\n<li>\n<p>运行node index.js;</p>\n</li>\n<li>\n<p>在浏览器中<code>http://localhost:8081/index.html</code>访问结果。</p>\n</li>\n</ol>\n<h2>vue-hackernews-2.0</h2>\n<p>工程化的代码。</p>\n<p><a href=\"https://github.com/vuejs/vue-hackernews-2.0\">https://github.com/vuejs/vue-hackernews-2.0</a></p>\n<p>直接打不开，loading不出来，可能是因为网络环境的原因：它使用的是外国的服务器，可能本地打不开。</p>\n<p>这是vue 官方提供的服务器渲染的demo。可以去研究下。</p>\n<h2>nuxt</h2>\n<p>这是一个第三方的脚手架工具，它具备交互式的操作方式 ，让我们从0开始去搭建一个应用。</p>\n<p>npx</p>\n<p>npm v5.2.0引入一个命令 npx.</p>\n<p>npx create-react-app my-app</p>\n<p>不需要提前安装全局命令</p>\n<p>npm install -g create-react-app</p>\n<p>create-react-app my-app;</p>\n<h3>安装工程代码</h3>\n<p>两种方式</p>\n<ol>\n<li></li>\n</ol>\n<p><code>npx create-nuxt-app demo-nuxt</code></p>\n<ol start=\"2\">\n<li><code>npm install -g create-nuxt-app create-nuxt-app yourproject</code></li>\n</ol>\n<p><img src=\"20190701_vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93_render-in-server.assets/1561951208639.png\" alt=\"1561951208639\"></p>\n<h3>启动</h3>\n<h3>基本配置</h3>\n<p>样式配置</p>\n<ul>\n<li>安装 less需要的各种包</li>\n</ul>\n<h3>路由</h3>\n<p>在layout.vue中有一个容器 nuxt。</p>\n<p>与vue中的路由使用相似，我们两个组件来表示路由的效果：</p>\n<p>在vue中是: router-link, router-view。在nuxt是nuxt-link和nuxt。nuxt-link表示类似于a标签的跳转，而nuxt是表示容器</p>\n<p>虚拟路由配置</p>\n<p>与vue中的需要明确的路由配置不同，nuxt中的路由配置是由文件所在的位置及命名来确定的。</p>\n<h2>视图</h2>\n<h3>app.html</h3>\n<p>在根目录下使用app.html。它的默认结构如下：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html {{ HTML_ATTRS }}&gt;\n  &lt;head {{ HEAD_ATTRS }}&gt;\n    {{ HEAD }}\n  &lt;/head&gt;\n  &lt;body {{ BODY_ATTRS }}&gt;\n    {{ APP }}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>你可以把它理解为一个默认的结构，{{APP}}表示一个占位符，在项目跑起来之后，会由layouts中的default.vue代替。</p>\n<p>一般不要需要去改动它。</p>\n<h2>asyncData</h2>\n<p>在每个页面组件加载之前，去异步请求数据。它是nuxt.js为我们额外提供的一个api。</p>\n<pre><code class=\"language-javascript\">const axios = require('axios');\nexport default{法\n    // 第一种写法\n    asyncData(){\n        return axios.get().then(res=&gt;{\n            return {list:res.data}\n        })\n    },\n    // 第二种写法\n    async asyncData(){\n        let {data} = await axios.get();\n        return {list:data}\n    }\n}\n</code></pre>\n<p>注意：</p>\n<ul>\n<li>它的结果会自己合并到data属性中，</li>\n</ul>\n<h2>资源文件</h2>\n<ul>\n<li>asset：会被webpack处理。例如，较小体积的图片可能会被处理成base64的图</li>\n<li>static：不会被webpack处理。</li>\n</ul>\n<h2>vuex</h2>\n<p>store/index.js</p>\n<pre><code class=\"language-javascript\">import Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\n\nconst store = () =&gt;\n  new Vuex.Store({\n    state: {\n      counter: 1\n    },\n    mutations: {\n      add(state) {\n        state.counter++;\n      }\n    }\n  });\n\nexport default store;\n</code></pre>\n<p>注意：</p>\n<ol>\n<li>store是一个函数，而不是一个对象。</li>\n</ol>\n","date_time":"2019-07-01","id":"02","name":"vue服务器端渲染","slug_name":"vue-fu-wu-qi-duan-xuan-ran","link_name":"04vue-ji-chu/02vue-fu-wu-qi-duan-xuan-ran.html","course_name":"vue基础"}],"target":"学习完成之后能达到的目标是什么","index_path":"04vue-ji-chu/index.html","basic":"你需要的一些基础知识是什么。"}]